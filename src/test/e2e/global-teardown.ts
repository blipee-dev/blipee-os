/**
 * Global E2E Test Teardown
 * Phase 5, Task 5.1: Test environment cleanup
 */

import { FullConfig } from '@playwright/test';
import { execSync } from 'child_process';
import fs from 'fs';
import path from 'path';

async function globalTeardown(config: FullConfig) {
  console.log('\nüßπ Starting E2E Test Environment Cleanup...\n');

  try {
    // 1. Generate test reports
    console.log('1Ô∏è‚É£ Generating test reports...');
    await generateTestReport();
    console.log('‚úÖ Test reports generated');

    // 2. Cleanup test data
    console.log('\n2Ô∏è‚É£ Cleaning up test data...');
    await cleanupTestData();
    console.log('‚úÖ Test data cleaned up');

    // 3. Archive test artifacts
    console.log('\n3Ô∏è‚É£ Archiving test artifacts...');
    await archiveTestArtifacts();
    console.log('‚úÖ Test artifacts archived');

    // 4. Stop mock services
    if (process.env.USE_MOCK_SERVICES === 'true') {
      console.log('\n4Ô∏è‚É£ Stopping mock services...');
      await stopMockServices();
      console.log('‚úÖ Mock services stopped');
    }

    // 5. Database cleanup
    if (process.env.CLEANUP_TEST_DB === 'true') {
      console.log('\n5Ô∏è‚É£ Cleaning up test database...');
      try {
        execSync('npm run db:reset:test', { stdio: 'inherit' });
        console.log('‚úÖ Test database cleaned');
      } catch (error) {
        console.warn('‚ö†Ô∏è Test database cleanup failed:', error);
      }
    }

    console.log('\nüéâ E2E Test Environment Cleanup Complete!\n');

  } catch (error) {
    console.error('\n‚ùå E2E Test Cleanup Failed:', error);
    // Don't throw error in teardown to avoid masking test failures
  }
}

async function generateTestReport() {
  const testResultsPath = 'test-results/test-results.json';
  
  if (!fs.existsSync(testResultsPath)) {
    console.log('‚ÑπÔ∏è No test results file found, skipping report generation');
    return;
  }

  try {
    const testResults = JSON.parse(fs.readFileSync(testResultsPath, 'utf8'));
    
    const report = {
      timestamp: new Date().toISOString(),
      summary: {
        total: testResults.stats?.total || 0,
        passed: testResults.stats?.passed || 0,
        failed: testResults.stats?.failed || 0,
        skipped: testResults.stats?.skipped || 0,
        duration: testResults.stats?.duration || 0
      },
      suites: testResults.suites?.map((suite: any) => ({
        title: suite.title,
        tests: suite.tests?.length || 0,
        passed: suite.tests?.filter((t: any) => t.status === 'passed').length || 0,
        failed: suite.tests?.filter((t: any) => t.status === 'failed').length || 0
      })) || [],
      environment: {
        baseURL: process.env.TEST_BASE_URL || 'http://localhost:3000',
        nodeEnv: process.env.NODE_ENV || 'test',
        ci: process.env.CI === 'true',
        timestamp: new Date().toISOString()
      }
    };

    // Write summary report
    const summaryPath = 'test-results/test-summary.json';
    fs.writeFileSync(summaryPath, JSON.stringify(report, null, 2));

    // Generate markdown report
    const markdownReport = generateMarkdownReport(report);
    const markdownPath = 'test-results/TEST_REPORT.md';
    fs.writeFileSync(markdownPath, markdownReport);

    console.log(`üìä Test summary: ${report.summary.passed}/${report.summary.total} tests passed`);
    console.log(`‚è±Ô∏è Total duration: ${(report.summary.duration / 1000).toFixed(1)}s`);

  } catch (error) {
    console.warn('‚ö†Ô∏è Failed to generate test report:', error);
  }
}

function generateMarkdownReport(report: any): string {
  const successRate = ((report.summary.passed / report.summary.total) * 100).toFixed(1);
  const duration = (report.summary.duration / 1000).toFixed(1);

  return `# E2E Test Report

## Summary

- **Total Tests**: ${report.summary.total}
- **Passed**: ${report.summary.passed} ‚úÖ
- **Failed**: ${report.summary.failed} ‚ùå
- **Skipped**: ${report.summary.skipped} ‚è≠Ô∏è
- **Success Rate**: ${successRate}%
- **Duration**: ${duration}s

## Test Suites

${report.suites.map((suite: any) => `
### ${suite.title}
- Tests: ${suite.tests}
- Passed: ${suite.passed} ‚úÖ
- Failed: ${suite.failed} ‚ùå
`).join('')}

## Environment

- **Base URL**: ${report.environment.baseURL}
- **Environment**: ${report.environment.nodeEnv}
- **CI**: ${report.environment.ci}
- **Timestamp**: ${report.environment.timestamp}

---

*Generated by blipee-os E2E Test Suite*
`;
}

async function cleanupTestData() {
  const testOrganizations = [
    'test-org-123',
    'test-org-sustainability',
    'test-org-ai'
  ];

  const testUsers = [
    'test.user@blipee-test.com',
    'sustainability.manager@blipee-test.com',
    'ai.user@blipee-test.com',
    'analyst@blipee-test.com'
  ];

  // Cleanup test organizations
  for (const orgId of testOrganizations) {
    try {
      const response = await fetch(`${process.env.TEST_BASE_URL || 'http://localhost:3000'}/api/organizations/${orgId}`, {
        method: 'DELETE',
        headers: {
          'Content-Type': 'application/json'
        }
      });

      if (response.ok) {
        console.log(`üóëÔ∏è Deleted test organization: ${orgId}`);
      }
    } catch (error) {
      console.warn(`‚ö†Ô∏è Failed to delete organization ${orgId}:`, error);
    }
  }

  // Cleanup test users
  for (const userEmail of testUsers) {
    try {
      const response = await fetch(`${process.env.TEST_BASE_URL || 'http://localhost:3000'}/api/auth/users/${encodeURIComponent(userEmail)}`, {
        method: 'DELETE',
        headers: {
          'Content-Type': 'application/json'
        }
      });

      if (response.ok) {
        console.log(`üóëÔ∏è Deleted test user: ${userEmail}`);
      }
    } catch (error) {
      console.warn(`‚ö†Ô∏è Failed to delete user ${userEmail}:`, error);
    }
  }
}

async function archiveTestArtifacts() {
  const artifactsDir = 'test-results/artifacts';
  const archiveDir = `test-results/archives/${new Date().toISOString().replace(/[:.]/g, '-')}`;

  try {
    // Create archive directory
    if (!fs.existsSync(archiveDir)) {
      fs.mkdirSync(archiveDir, { recursive: true });
    }

    // Move artifacts to archive
    if (fs.existsSync(artifactsDir)) {
      const files = fs.readdirSync(artifactsDir);
      
      for (const file of files) {
        const srcPath = path.join(artifactsDir, file);
        const destPath = path.join(archiveDir, file);
        
        if (fs.statSync(srcPath).isFile()) {
          fs.copyFileSync(srcPath, destPath);
        }
      }
      
      console.log(`üì¶ Archived ${files.length} test artifacts`);
    }

    // Cleanup old archives (keep last 10)
    const archivesDir = 'test-results/archives';
    if (fs.existsSync(archivesDir)) {
      const archives = fs.readdirSync(archivesDir)
        .map(name => ({
          name,
          path: path.join(archivesDir, name),
          mtime: fs.statSync(path.join(archivesDir, name)).mtime
        }))
        .sort((a, b) => b.mtime.getTime() - a.mtime.getTime());

      // Remove old archives
      if (archives.length > 10) {
        const toRemove = archives.slice(10);
        for (const archive of toRemove) {
          fs.rmSync(archive.path, { recursive: true, force: true });
        }
        console.log(`üóëÔ∏è Cleaned up ${toRemove.length} old archives`);
      }
    }

  } catch (error) {
    console.warn('‚ö†Ô∏è Failed to archive test artifacts:', error);
  }
}

async function stopMockServices() {
  console.log('Stopping mock AI services...');
  console.log('Stopping mock utility APIs...');
  console.log('Stopping mock compliance services...');
}

export default globalTeardown;