{"version":3,"sources":["/workspaces/blipee-os/src/lib/monitoring/collector.ts"],"sourcesContent":["import { MetricType } from './types';\nimport { monitoringService } from './service';\n\n/**\n * Metrics collector for application instrumentation\n */\nexport class MetricsCollector {\n  /**\n   * Record HTTP request\n   */\n  static async recordHttpRequest(\n    method: string,\n    path: string,\n    statusCode: number,\n    responseTime: number,\n    userId?: string\n  ): Promise<void> {\n    // Record request count\n    await monitoringService.recordMetric({\n      name: 'http_requests_total',\n      type: MetricType.COUNTER,\n      value: 1,\n      labels: {\n        method,\n        path,\n        status: statusCode >= 200 && statusCode < 300 ? 'success' : 'failure',\n        statusCode: statusCode.toString(),\n      },\n    });\n\n    // Record response time\n    await monitoringService.recordMetric({\n      name: 'http_response_time_ms',\n      type: MetricType.HISTOGRAM,\n      value: responseTime,\n      labels: {\n        method,\n        path,\n      },\n    });\n\n    // Record active connections\n    await monitoringService.recordMetric({\n      name: 'active_connections',\n      type: MetricType.GAUGE,\n      value: 1, // This would be tracked properly in a real implementation\n    });\n\n    // Record errors\n    if (statusCode >= 400) {\n      await monitoringService.recordMetric({\n        name: 'http_errors_total',\n        type: MetricType.COUNTER,\n        value: 1,\n        labels: {\n          method,\n          path,\n          statusCode: statusCode.toString(),\n          errorType: statusCode >= 500 ? 'server_error' : 'client_error',\n        },\n      });\n    }\n  }\n\n  /**\n   * Record authentication event\n   */\n  static async recordAuthEvent(\n    event: 'login' | 'logout' | 'register' | 'mfa_verify',\n    success: boolean,\n    method?: string,\n    userId?: string\n  ): Promise<void> {\n    const labels: Record<string, string> = {\n      event,\n      success: success.toString(),\n    };\n    \n    if (method) {\n      labels.method = method;\n    }\n\n    await monitoringService.recordMetric({\n      name: 'auth_events_total',\n      type: MetricType.COUNTER,\n      value: 1,\n      labels,\n    });\n\n    // Specific metrics for monitoring\n    if (event === 'login') {\n      await monitoringService.recordMetric({\n        name: 'login_attempts_total',\n        type: MetricType.COUNTER,\n        value: 1,\n        labels: { success: success.toString() },\n      });\n\n      if (!success) {\n        await monitoringService.recordMetric({\n          name: 'failed_logins_total',\n          type: MetricType.COUNTER,\n          value: 1,\n          labels: method ? { method } : {},\n        });\n      }\n    } else if (event === 'mfa_verify') {\n      await monitoringService.recordMetric({\n        name: 'mfa_verifications_total',\n        type: MetricType.COUNTER,\n        value: 1,\n        labels: { success: success.toString(), method: method || 'unknown' },\n      });\n    }\n  }\n\n  /**\n   * Record rate limit event\n   */\n  static async recordRateLimit(\n    identifier: string,\n    endpoint: string,\n    limited: boolean\n  ): Promise<void> {\n    if (limited) {\n      await monitoringService.recordMetric({\n        name: 'rate_limit_exceeded_total',\n        type: MetricType.COUNTER,\n        value: 1,\n        labels: {\n          endpoint,\n          identifier: identifier.substring(0, 8), // Partial identifier for privacy\n        },\n      });\n    }\n\n    await monitoringService.recordMetric({\n      name: 'rate_limit_checks_total',\n      type: MetricType.COUNTER,\n      value: 1,\n      labels: {\n        endpoint,\n        limited: limited.toString(),\n      },\n    });\n  }\n\n  /**\n   * Record database query\n   */\n  static async recordDatabaseQuery(\n    operation: string,\n    table: string,\n    duration: number,\n    success: boolean\n  ): Promise<void> {\n    await monitoringService.recordMetric({\n      name: 'database_queries_total',\n      type: MetricType.COUNTER,\n      value: 1,\n      labels: {\n        operation,\n        table,\n        success: success.toString(),\n      },\n    });\n\n    await monitoringService.recordMetric({\n      name: 'database_query_duration_ms',\n      type: MetricType.HISTOGRAM,\n      value: duration,\n      labels: {\n        operation,\n        table,\n      },\n    });\n  }\n\n  /**\n   * Record cache operation\n   */\n  static async recordCacheOperation(\n    operation: 'get' | 'set' | 'delete',\n    hit: boolean,\n    duration: number\n  ): Promise<void> {\n    await monitoringService.recordMetric({\n      name: 'cache_operations_total',\n      type: MetricType.COUNTER,\n      value: 1,\n      labels: {\n        operation,\n        hit: hit.toString(),\n      },\n    });\n\n    if (operation === 'get') {\n      await monitoringService.recordMetric({\n        name: hit ? 'cache_hits_total' : 'cache_misses_total',\n        type: MetricType.COUNTER,\n        value: 1,\n      });\n    }\n\n    await monitoringService.recordMetric({\n      name: 'cache_operation_duration_ms',\n      type: MetricType.HISTOGRAM,\n      value: duration,\n      labels: { operation },\n    });\n  }\n\n  /**\n   * Record external API call\n   */\n  static async recordApiCall(\n    service: string,\n    endpoint: string,\n    statusCode: number,\n    duration: number\n  ): Promise<void> {\n    await monitoringService.recordMetric({\n      name: 'external_api_calls_total',\n      type: MetricType.COUNTER,\n      value: 1,\n      labels: {\n        service,\n        endpoint,\n        success: (statusCode >= 200 && statusCode < 300).toString(),\n        statusCode: statusCode.toString(),\n      },\n    });\n\n    await monitoringService.recordMetric({\n      name: 'external_api_duration_ms',\n      type: MetricType.HISTOGRAM,\n      value: duration,\n      labels: {\n        service,\n        endpoint,\n      },\n    });\n  }\n\n  /**\n   * Record business metric\n   */\n  static async recordBusinessMetric(\n    name: string,\n    value: number,\n    labels?: Record<string, string>\n  ): Promise<void> {\n    await monitoringService.recordMetric({\n      name: `business_${name}`,\n      type: MetricType.GAUGE,\n      value,\n      labels,\n    });\n  }\n\n  /**\n   * Record system metrics (should be called periodically)\n   */\n  static async recordSystemMetrics(): Promise<void> {\n    // CPU usage (mock for now)\n    const cpuUsage = Math.random() * 100;\n    await monitoringService.recordMetric({\n      name: 'system_cpu_usage_percent',\n      type: MetricType.GAUGE,\n      value: cpuUsage,\n    });\n\n    // Memory usage\n    const memoryUsage = process.memoryUsage();\n    const totalMemory = memoryUsage.heapTotal;\n    const usedMemory = memoryUsage.heapUsed;\n    const memoryPercent = (usedMemory / totalMemory) * 100;\n\n    await monitoringService.recordMetric({\n      name: 'system_memory_usage_percent',\n      type: MetricType.GAUGE,\n      value: memoryPercent,\n    });\n\n    await monitoringService.recordMetric({\n      name: 'system_memory_usage_bytes',\n      type: MetricType.GAUGE,\n      value: usedMemory,\n      labels: { type: 'heap_used' },\n    });\n\n    await monitoringService.recordMetric({\n      name: 'system_memory_usage_bytes',\n      type: MetricType.GAUGE,\n      value: totalMemory,\n      labels: { type: 'heap_total' },\n    });\n\n    // Disk usage (mock for now)\n    const diskUsage = Math.random() * 100;\n    await monitoringService.recordMetric({\n      name: 'system_disk_usage_percent',\n      type: MetricType.GAUGE,\n      value: diskUsage,\n    });\n  }\n\n  /**\n   * Record feature usage\n   */\n  static async recordFeatureUsage(\n    feature: string,\n    userId?: string,\n    metadata?: Record<string, string>\n  ): Promise<void> {\n    await monitoringService.recordMetric({\n      name: 'feature_usage_total',\n      type: MetricType.COUNTER,\n      value: 1,\n      labels: {\n        feature,\n        ...metadata,\n      },\n    });\n  }\n\n  /**\n   * Record error\n   */\n  static async recordError(\n    errorType: string,\n    errorMessage: string,\n    context?: Record<string, string>\n  ): Promise<void> {\n    await monitoringService.recordMetric({\n      name: 'errors_total',\n      type: MetricType.COUNTER,\n      value: 1,\n      labels: {\n        type: errorType,\n        ...context,\n      },\n    });\n\n    // Also record as security event if it's security-related\n    const securityErrorTypes = [\n      'authentication_failed',\n      'authorization_failed',\n      'invalid_token',\n      'suspicious_activity',\n      'rate_limit_exceeded',\n    ];\n\n    if (securityErrorTypes.includes(errorType)) {\n      await monitoringService.recordSecurityEvent({\n        id: crypto.randomUUID(),\n        type: errorType,\n        severity: 'warning',\n        source: 'application',\n        details: {\n          message: errorMessage,\n          ...context,\n        },\n        timestamp: new Date(),\n        handled: true,\n      });\n    }\n  }\n}\n\n// Export convenience functions\nexport const {\n  recordHttpRequest,\n  recordAuthEvent,\n  recordRateLimit,\n  recordDatabaseQuery,\n  recordCacheOperation,\n  recordApiCall,\n  recordBusinessMetric,\n  recordSystemMetrics,\n  recordFeatureUsage,\n  recordError,\n} = MetricsCollector;"],"names":["MetricsCollector","recordApiCall","recordAuthEvent","recordBusinessMetric","recordCacheOperation","recordDatabaseQuery","recordError","recordFeatureUsage","recordHttpRequest","recordRateLimit","recordSystemMetrics","method","path","statusCode","responseTime","userId","monitoringService","recordMetric","name","type","MetricType","COUNTER","value","labels","status","toString","HISTOGRAM","GAUGE","errorType","event","success","identifier","endpoint","limited","substring","operation","table","duration","hit","service","cpuUsage","Math","random","memoryUsage","process","totalMemory","heapTotal","usedMemory","heapUsed","memoryPercent","diskUsage","feature","metadata","errorMessage","context","securityErrorTypes","includes","recordSecurityEvent","id","crypto","randomUUID","severity","source","details","message","timestamp","Date","handled"],"mappings":"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"}