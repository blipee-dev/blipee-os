{"version":3,"sources":["/workspaces/blipee-os/src/lib/monitoring/health.ts"],"sourcesContent":["import { HealthCheck } from './types';\nimport { monitoringService } from './service';\nimport { supabaseAdmin } from '@/lib/supabase/admin';\nimport { sessionStore } from '@/lib/auth/session-store';\n\n/**\n * Health check service for monitoring system components\n */\nexport class HealthCheckService {\n  private checks: Map<string, () => Promise<HealthCheck>> = new Map();\n  private interval: NodeJS.Timeout | null = null;\n\n  constructor() {\n    this.registerDefaultChecks();\n  }\n\n  /**\n   * Register default health checks\n   */\n  private registerDefaultChecks(): void {\n    // Database health check\n    this.register('database', async () => {\n      const startTime = Date.now();\n      try {\n        const { data, error } = await supabaseAdmin\n          .from('health_check')\n          .select('status')\n          .single();\n        \n        const responseTime = Date.now() - startTime;\n        \n        if (error && error.code !== 'PGRST116') { // Table doesn't exist is ok\n          return {\n            service: 'database',\n            status: 'unhealthy',\n            responseTime,\n            lastCheck: new Date(),\n            details: { error: error.message },\n          };\n        }\n        \n        return {\n          service: 'database',\n          status: responseTime < 1000 ? 'healthy' : 'degraded',\n          responseTime,\n          lastCheck: new Date(),\n        };\n      } catch (error) {\n        return {\n          service: 'database',\n          status: 'unhealthy',\n          responseTime: Date.now() - startTime,\n          lastCheck: new Date(),\n          details: { error: error instanceof Error ? error.message : 'Unknown error' },\n        };\n      }\n    });\n\n    // Redis/Session store health check\n    this.register('session-store', async () => {\n      const startTime = Date.now();\n      try {\n        // Test set and get\n        const testKey = 'health-check-test';\n        const testValue = { test: true, timestamp: Date.now() };\n        \n        await sessionStore.set(testKey, testValue, 10); // 10 second TTL\n        const retrieved = await sessionStore.get(testKey);\n        await sessionStore.delete(testKey);\n        \n        const responseTime = Date.now() - startTime;\n        \n        if (!retrieved || retrieved.timestamp !== testValue.timestamp) {\n          return {\n            service: 'session-store',\n            status: 'unhealthy',\n            responseTime,\n            lastCheck: new Date(),\n            details: { error: 'Data integrity check failed' },\n          };\n        }\n        \n        return {\n          service: 'session-store',\n          status: responseTime < 100 ? 'healthy' : 'degraded',\n          responseTime,\n          lastCheck: new Date(),\n        };\n      } catch (error) {\n        return {\n          service: 'session-store',\n          status: 'unhealthy',\n          responseTime: Date.now() - startTime,\n          lastCheck: new Date(),\n          details: { error: error instanceof Error ? error.message : 'Unknown error' },\n        };\n      }\n    });\n\n    // API health check\n    this.register('api', async () => {\n      const startTime = Date.now();\n      try {\n        const response = await fetch(`${process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000'}/api/health`, {\n          method: 'GET',\n          signal: AbortSignal.timeout(5000), // 5 second timeout\n        });\n        \n        const responseTime = Date.now() - startTime;\n        \n        if (!response.ok) {\n          return {\n            service: 'api',\n            status: 'unhealthy',\n            responseTime,\n            lastCheck: new Date(),\n            details: { statusCode: response.status },\n          };\n        }\n        \n        return {\n          service: 'api',\n          status: responseTime < 500 ? 'healthy' : 'degraded',\n          responseTime,\n          lastCheck: new Date(),\n        };\n      } catch (error) {\n        return {\n          service: 'api',\n          status: 'unhealthy',\n          responseTime: Date.now() - startTime,\n          lastCheck: new Date(),\n          details: { error: error instanceof Error ? error.message : 'Unknown error' },\n        };\n      }\n    });\n\n    // Memory health check\n    this.register('memory', async () => {\n      const memoryUsage = process.memoryUsage();\n      const heapUsedPercent = (memoryUsage.heapUsed / memoryUsage.heapTotal) * 100;\n      \n      let status: 'healthy' | 'degraded' | 'unhealthy';\n      if (heapUsedPercent < 70) {\n        status = 'healthy';\n      } else if (heapUsedPercent < 85) {\n        status = 'degraded';\n      } else {\n        status = 'unhealthy';\n      }\n      \n      return {\n        service: 'memory',\n        status,\n        lastCheck: new Date(),\n        details: {\n          heapUsed: Math.round(memoryUsage.heapUsed / 1024 / 1024), // MB\n          heapTotal: Math.round(memoryUsage.heapTotal / 1024 / 1024), // MB\n          heapUsedPercent: Math.round(heapUsedPercent),\n          rss: Math.round(memoryUsage.rss / 1024 / 1024), // MB\n        },\n      };\n    });\n  }\n\n  /**\n   * Register a health check\n   */\n  register(name: string, check: () => Promise<HealthCheck>): void {\n    this.checks.set(name, check);\n  }\n\n  /**\n   * Unregister a health check\n   */\n  unregister(name: string): void {\n    this.checks.delete(name);\n  }\n\n  /**\n   * Run all health checks\n   */\n  async runAll(): Promise<HealthCheck[]> {\n    const results: HealthCheck[] = [];\n    \n    for (const [name, check] of this.checks) {\n      try {\n        const result = await check();\n        results.push(result);\n        \n        // Update monitoring service\n        await monitoringService.updateHealthCheck(result);\n      } catch (error) {\n        const errorResult: HealthCheck = {\n          service: name,\n          status: 'unhealthy',\n          lastCheck: new Date(),\n          details: {\n            error: error instanceof Error ? error.message : 'Health check failed',\n          },\n        };\n        results.push(errorResult);\n        await monitoringService.updateHealthCheck(errorResult);\n      }\n    }\n    \n    return results;\n  }\n\n  /**\n   * Run a specific health check\n   */\n  async run(name: string): Promise<HealthCheck | null> {\n    const check = this.checks.get(name);\n    if (!check) return null;\n    \n    try {\n      const result = await check();\n      await monitoringService.updateHealthCheck(result);\n      return result;\n    } catch (error) {\n      const errorResult: HealthCheck = {\n        service: name,\n        status: 'unhealthy',\n        lastCheck: new Date(),\n        details: {\n          error: error instanceof Error ? error.message : 'Health check failed',\n        },\n      };\n      await monitoringService.updateHealthCheck(errorResult);\n      return errorResult;\n    }\n  }\n\n  /**\n   * Get overall system health\n   */\n  async getSystemHealth(): Promise<{\n    status: 'healthy' | 'degraded' | 'unhealthy';\n    checks: HealthCheck[];\n    summary: {\n      total: number;\n      healthy: number;\n      degraded: number;\n      unhealthy: number;\n    };\n  }> {\n    const checks = await this.runAll();\n    \n    const summary = {\n      total: checks.length,\n      healthy: checks.filter(c => c.status === 'healthy').length,\n      degraded: checks.filter(c => c.status === 'degraded').length,\n      unhealthy: checks.filter(c => c.status === 'unhealthy').length,\n    };\n    \n    let status: 'healthy' | 'degraded' | 'unhealthy';\n    if (summary.unhealthy > 0) {\n      status = 'unhealthy';\n    } else if (summary.degraded > 0) {\n      status = 'degraded';\n    } else {\n      status = 'healthy';\n    }\n    \n    return {\n      status,\n      checks,\n      summary,\n    };\n  }\n\n  /**\n   * Start periodic health checks\n   */\n  startPeriodicChecks(intervalMs: number = 60000): void {\n    if (this.interval) {\n      clearInterval(this.interval);\n    }\n    \n    // Run immediately\n    this.runAll().catch(console.error);\n    \n    // Then run periodically\n    this.interval = setInterval(() => {\n      this.runAll().catch(console.error);\n    }, intervalMs);\n  }\n\n  /**\n   * Stop periodic health checks\n   */\n  stopPeriodicChecks(): void {\n    if (this.interval) {\n      clearInterval(this.interval);\n      this.interval = null;\n    }\n  }\n\n  /**\n   * Check if a service is healthy\n   */\n  async isHealthy(service: string): Promise<boolean> {\n    const result = await this.run(service);\n    return result?.status === 'healthy';\n  }\n\n  /**\n   * Wait for all services to be healthy\n   */\n  async waitForHealth(\n    timeoutMs: number = 30000,\n    checkIntervalMs: number = 1000\n  ): Promise<boolean> {\n    const startTime = Date.now();\n    \n    while (Date.now() - startTime < timeoutMs) {\n      const health = await this.getSystemHealth();\n      \n      if (health.status === 'healthy') {\n        return true;\n      }\n      \n      await new Promise(resolve => setTimeout(resolve, checkIntervalMs));\n    }\n    \n    return false;\n  }\n}\n\n// Export singleton instance\nexport const healthCheckService = new HealthCheckService();\n\n// Export convenience functions\nexport const {\n  register: registerHealthCheck,\n  unregister: unregisterHealthCheck,\n  runAll: runAllHealthChecks,\n  run: runHealthCheck,\n  getSystemHealth,\n  isHealthy: isServiceHealthy,\n  waitForHealth,\n} = healthCheckService;"],"names":["HealthCheckService","getSystemHealth","healthCheckService","isServiceHealthy","registerHealthCheck","runAllHealthChecks","runHealthCheck","unregisterHealthCheck","waitForHealth","constructor","checks","Map","interval","registerDefaultChecks","register","startTime","Date","now","data","error","supabaseAdmin","from","select","single","responseTime","code","service","status","lastCheck","details","message","Error","testKey","testValue","test","timestamp","sessionStore","set","retrieved","get","delete","response","fetch","process","env","NEXT_PUBLIC_APP_URL","method","signal","AbortSignal","timeout","ok","statusCode","memoryUsage","heapUsedPercent","heapUsed","heapTotal","Math","round","rss","name","check","unregister","runAll","results","result","push","monitoringService","updateHealthCheck","errorResult","run","summary","total","length","healthy","filter","c","degraded","unhealthy","startPeriodicChecks","intervalMs","clearInterval","catch","console","setInterval","stopPeriodicChecks","isHealthy","timeoutMs","checkIntervalMs","health","Promise","resolve","setTimeout"],"mappings":"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"}